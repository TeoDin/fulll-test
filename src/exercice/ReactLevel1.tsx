import React, {Dispatch, FC, useState} from "react";

// Interface is a must for autocompletion, this is why we like to use Typescript
interface ListItem {
  id: number;
  label: string;
  action: (list: ListItem[], itemId: number) => ListItem[];
  selected?: boolean;
}

// Mocked Datas, this can be generated by an other function
// the "action" is here to abstract business rules from the "data displayer" component
// and concentrate all configuration on one object.
const exampleList: ListItem[] = [
  {id: 0, label: 'Tout sÃ©lectionner', action: selectAll},
  {id: 1, label: 'Item 1', action: toggleMe},
  {id: 2, label: 'Item 2', action: toggleMe},
  {id: 3, label: 'Item 3', action: toggleMe},
  {id: 4, label: 'Item 4', action: toggleMe},
]

function selectAll(list: ListItem[]): ListItem[] {
  const select = areAllItemSelected(list);
  for (let item of list) item.selected = !select;
  // Create a new instance for hook trigger rendering
  return [...list];
}

function areAllItemSelected(list: ListItem[]): boolean {
  for (let item of list) if (!item.selected) return false;
  return true;
}

function toggleMe(list: ListItem[], itemId: number): ListItem[] {
  if (!list || list.length === 0) return [];
  const itemToFind = list.find(x => x.id === itemId);
  if (!itemToFind) return list;
  itemToFind.selected = !itemToFind.selected;
  // We assume that the first item will always be the "toggle all"
  list[0].selected = areAllItemSelected(list.slice(1, list.length));
  return [...list];
}

// Business Component,
// The meaning of this component is to handle business rules and call display componants to show the results
const ReactLevel1Page: FC = () => {
  const [list, setList] = useState<ListItem[]>(exampleList);

  return (
    <div>
      <h2>React level 1</h2>
      <ReactLevel1Component list={list} onItemClick={(item: ListItem) => setList(item.action(list, item.id))}/>
    </div>
  );
}

// Display component
// The meaning is to have display component on one side and business component on an other side
// The display components can be reused this way (putting them in internal project librairies)
const ReactLevel1Component: FC<{ list: ListItem[], onItemClick: Dispatch<any> }> = ({list, onItemClick}) => {
  return (
    <div>
      {list.map((item: ListItem) => (
        <div key={item.id}>
          <input type="checkbox" checked={!!item.selected} onChange={() => onItemClick(item)}/>
          <span>{item.label}</span>
        </div>
      ))}
    </div>
  )
}

export default ReactLevel1Page;
